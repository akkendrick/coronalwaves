;+
;
; NAME: plot_edges.pro
;
; USAGE: plot_edges, mask
; 
; PURPOSE: Uses IDL's PLOTS.PRO to overlay features' boundaries,
; colored
;    coded by label, on images (e.g., those created by DISPLAY.PRO).
;
; ARGUMENTS: MASK = 2-D array of each pixel's feature's label,
;    generated by, e.g., RANKDOWN.PRO
;
; OPTIONAL ARGUMENTS/KEYWORDS:
;    SETCOLOR= set to force color of plotted boundary
;    CT= color table to for color coding features' labels; DEFAULT=13
;    DCOLOR= color shift between labels {i,i+1}; DEFAULT=23
;    MIN_COL= min. color to use (excludes colors); DEFAULT=30
;    MAX_COL= max. color to use (excludes colors); DEFAULT=255
;    THICK= thickness of characters used in labels; DEFAULT=3
;    DX= displacement of plotted line from pixel edge; DEFAULT=0
;    EDGEPIX = 1D addresses pixels on edges
;
; SIDE EFFECTS/ROUTINES CALLED: PLOTS.PRO, LOADCT.PRO
; 
; HISTORY: Written 27 March 2005, BTW
;   05/19/05, BTW: Fixed bug with max_col
;   05/31/05, BTW: Changed not(keyword_set(ct)) to (n_elements(ct) eq
;   0) 
;   07/08/05, BTW: Added edgepix keyword to return edge pixels'
;   addresses
;   03/11/08, BTW: Added setcolor keyword, to enable forcing color
;   04/02/08, BTW: Fixed bug introduced with setcolor change!
;   05/17/09, BTW: Converted loop indices to FLOAT, for large feature #'s
;
;- 

pro plot_edges, mask, ct=ct,dcolor=dcolor,min_col=min_col, $
                max_col=max_col,thick=thick,dx=dx, $
                edgepix=edgepix, setcolor=setcolor

nx = n_elements(mask(*,0))
ny = n_elements(mask(0,*))

if not(keyword_set(dx)) then dx=0.

if (n_elements(ct) eq 0) then ct=13
if not(keyword_set(dcolor)) then dcolor=23
if not(keyword_set(min_col)) then min_col=30
if not(keyword_set(max_col)) then max_col=255

; Z-buffer color table must be handled externally!
input_device = !d.name
if (input_device ne 'Z') then loadct,ct,/silent

abmask = abs(mask)

; if lmask ne abmask, then it's a right edge
;=========================================
lmask = shift(abmask,-1, 0)
right = where(lmask ne abmask and abmask ne 0, n_right)

rightx = right mod nx
righty = floor(right/float(nx))

for i=0.,n_right-1 do begin
    if (n_elements(setcolor) ne 0) then color = setcolor else $
      color=(dcolor*abmask(right(i)))mod(max_col-min_col) + min_col

    plots, $
      [rightx(i)+0.5-dx,rightx(i)+0.5-dx], $
      [righty(i)-.5+dx,righty(i)+.5], $
      color=color,thick=thick    
endfor

; if rmask ne abmask, then it's a left edge
;=========================================
rmask = shift(abmask, 1, 0)
left = where(rmask ne abmask and abmask ne 0, n_left)

leftx = left mod nx
lefty = floor(left/float(nx))

for i=0.,n_left-1 do begin
    if (n_elements(setcolor) ne 0) then color = setcolor else $
      color=(dcolor*abmask(left(i)))mod(max_col-min_col) + min_col
    plots, $
      [leftx(i)-0.5+dx,leftx(i)-0.5+dx], $
      [lefty(i)-.5,lefty(i)+.5-dx], $
      color=color,thick=thick
endfor

; if bmask ne abmask, then it's an upper edge
;=========================================
bmask = shift(abmask, 0,-1)
upper = where(bmask ne abmask and abmask ne 0, n_upper)

upperx = upper mod nx
uppery = floor(upper/float(nx))

for i=0.,n_upper-1 do begin
    if (n_elements(setcolor) ne 0) then color = setcolor else $
      color=(dcolor*abmask(upper(i)))mod(max_col-min_col) + min_col
    plots, $
      [upperx(i)-.5,upperx(i)+.5-dx], $
      [uppery(i)+0.5-dx,uppery(i)+0.5-dx], $
      color=color,thick=thick 
endfor

; if amask ne abmask, then it's a bottom edge
;=========================================
umask = shift(abmask, 0, 1)
bottom = where(umask ne abmask and abmask ne 0, n_bottom)

bottomx = bottom mod nx
bottomy = floor(bottom/float(nx))

for i=0.,n_bottom-1 do begin
    if (n_elements(setcolor) ne 0) then color = setcolor else $
      color=(dcolor*abmask(bottom(i)))mod(max_col-min_col) + min_col
    plots, $
      [bottomx(i)-.5+dx,bottomx(i)+.5],$
      [bottomy(i)-0.5+dx,bottomy(i)-0.5+dx], $
      color=color,thick=thick
endfor

if (input_device ne 'Z') then loadct,0,/silent

edgepix = [left,upper,right,bottom]

end

